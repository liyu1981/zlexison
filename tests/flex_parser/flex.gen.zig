// #line 2 "<stdout>"

// A lexical scanner generated by zlex

pub const version = [3]u8{ 2, 6, 4 };

const std = @import("std");
const Self = @This();
const YYLexer = @This();

pub const YY_NULL = 0;
pub const YY_END_OF_BUFFER_CHAR = 0;
pub const YY_BUF_SIZE = 32768;
pub const YY_READ_BUF_SIZE = 16384;
pub const YY_EXIT_FAILURE = 2;
pub const YY_TERMINATED = std.math.maxInt(usize);
pub const EOB_ACT_CONTINUE_SCAN = 0;
pub const EOB_ACT_END_OF_FILE = 1;
pub const EOB_ACT_LAST_MATCH = 2;

pub fn yywrap(yyg: *yyguts_t) usize {
    _ = yyg;
    return 1;
}
pub fn YY_USER_ACTION(this: *Self) anyerror!void {
    _ = this;
}
pub fn YY_USER_INIT(this: *Self) anyerror!void {
    _ = this;
}
pub const YYSTYPE = struct {};
pub const YYLTYPE = struct {};
pub const YY_EXTRA_TYPE = struct {};

allocator: std.mem.Allocator = undefined,
yyg: *yyguts_t = undefined,

pub inline fn YY_SC_TO_UI(comptime T: type, c: T) u8 {
    return c;
}

/// util for calculate c pointer distance.
inline fn cPtrDistance(comptime T: type, p1: [*c]T, p2: [*c]T) usize {
    return (@intFromPtr(p2) - @intFromPtr(p1)) / @sizeOf(T);
}

inline fn createZero(allocator: std.mem.Allocator, comptime T: type) !*T {
    var p = try allocator.create(T);
    _ = &p;
    p.* = std.mem.zeroInit(T, p.*);
    return p;
}

/// Enter a start condition. All start condition should be auto generated with names, like Self.INITIAL
pub fn BEGIN(c: usize, yyg: *yyguts_t) void {
    yyg.yy_start = 1 + 2 * c;
}

/// Translate the current start state into a value that can be later handed to
/// BEGIN to return to the state.  The YYSTATE alias is for lex compatibility.
pub fn YY_START(yyg: *yyguts_t) usize {
    return (yyg.yy_start - 1) / 2;
}

pub const YYSTATE = YY_START;

/// Action number for EOF rule of a given start state.
pub inline fn YY_STATE_EOF(state: usize) usize {
    return Self.YY_END_OF_BUFFER + state + 1;
}

/// Special action meaning "start processing a new file".
pub inline fn YY_NEW_FILE(yyg: *yyguts_t) !void {
    try yyrestart(yyg.yyin_r, yyg);
}

/// The state buf must be large enough to hold one state per character in the
/// main buffer.
pub const YY_STATE_BUF_SIZE = YY_BUF_SIZE + 2;

/// Note: We specifically omit the test for yy_rule_can_match_eol because it
/// requires access to the local variable yy_act. Since yyless() is a macro, it
/// would break existing scanners that call yyless() from OUTSIDE yylex. One
/// obvious solution it to make yy_act a global. I tried that, and saw a 5%
/// performance hit in a non-yylineno scanner, because yy_act is normally
/// declared as a register variable-- so it is not worth it.
pub inline fn YY_LESS_LINENO(n: usize, yyg: *yyguts_t) void {
    for (n..yyg.yyleng_r) |yyl| {
        if (yyg.yytext_r[yyl] == '\n')
            yyg.yylineno_r -= 1;
    }
}

pub fn YY_LINENO_REWIND_TO(dst: [*c]u8, yyg: *yyguts_t) void {
    var p: [*c]u8 = yyg.yy_cp - 1;
    while (p >= dst) : (p -= 1) {
        if (*p == '\n')
            yyg.yylineno -= 1;
    }
}

/// Return all but the first "n" matched characters back to the input stream.
pub fn yyless(n: usize, yyg: *yyguts_t) void {
    // Undo effects of setting up yytext.
    YY_LESS_LINENO(n, yyg);
    var yy_cp = yyg.yy_hold_char;
    yy_cp = yyg.yy_bp + n - yyg.yy_more_len;
    yyg.yy_c_buf_p = yy_cp;
    // TODO: definitely with problem
    YY_DO_BEFORE_ACTION(yyg); // set up yytext again
}

pub inline fn unput(c: u8, yyg: *yyguts_t) void {
    yyunput(c, yyg.yytext_r, yyg);
}

/// yy_buffer_state, most of fields are undefined(or 0) in default, must be
/// inited after create
pub const yy_buffer_state = struct {
    yy_input_file: std.fs.File = undefined,

    yy_ch_buf: [*c]u8 = 0, // input buffer
    yy_buf_pos: [*c]u8 = 0, // current position in input buffer

    yy_buf_size: usize = 0, // Size of input buffer in bytes, not including room for EOB characters.
    yy_n_chars: usize = 0, // Number of characters read into yy_ch_buf, not including EOB characters.

    yy_is_our_buffer: bool = false, // Whether we "own" the buffer - i.e., we know we created it, and can realloc() it to grow
    // it, and should free() it to delete it.

    yy_is_interactive: bool = false, // Whether this is an "interactive" input source; if so, and
    // if we're using stdio for input, then we want to use getc()
    // instead of fread(), to make sure we stop fetching input after
    // each newline.

    yy_at_bol: bool = false, // Whether we're considered to be at the beginning of a line.
    // If so, '^' rules will be active on the next match, otherwise
    // not.

    // lineno is special as in default is 1
    yy_bs_lineno: usize = 1, // *< The line count.
    yy_bs_column: usize = 0, // *< The column count.

    yy_fill_buffer: bool = false, // Whether to try to fill the input buffer when we reach the
    // end of it.

    yy_buffer_status: usize = 0,

    pub const YY_BUFFER_NEW = 0;
    pub const YY_BUFFER_NORMAL = 1;

    // When an EOF's been seen but there's still some text to process
    // then we mark the buffer as YY_EOF_PENDING, to indicate that we
    // shouldn't try reading from the input source any more.  We might
    // still have a bunch of tokens to match, though, because of
    // possible backing-up.
    //
    // When we actually see the EOF, we change the status to "new"
    // (via yyrestart()), so that the user can continue scanning by
    // just pointing yyin at a new input file.
    //
    pub const YY_BUFFER_EOF_PENDING = 2;
};

pub inline fn YY_FLUSH_BUFFER(yyg: *yyguts_t) void {
    const yy_current_buffer = yyg.yy_buffer_stack[yyg.yy_buffer_stack_top];
    yy_flush_buffer(yy_current_buffer, yyg);
}

pub const yy_new_buffer = yy_create_buffer;

pub fn yy_set_interactive(is_interactive: bool, yyg: *yyguts_t) !void {
    const yy_current_buffer = yyg.yy_buffer_stack[yyg.yy_buffer_stack_top];
    if (yy_current_buffer != null) {
        yyensure_buffer_stack(yyg);
        yyg.yy_buffer_stack[yyg.yy_buffer_stack_top].* = try yy_create_buffer(yyg.yyin, YY_BUF_SIZE, yyg);
    }
    yyg.yy_buffer_stack[yyg.yy_buffer_stack_top].yy_is_interactive = is_interactive;
}

pub fn yy_set_bol(at_bol: bool, yyg: *yyguts_t) void {
    const yy_current_buffer = yyg.yy_buffer_stack[yyg.yy_buffer_stack_top];
    if (yy_current_buffer != null) {
        yyensure_buffer_stack(yyg);
        yyg.yy_buffer_stack[yyg.yy_buffer_stack_top].* = try yy_create_buffer(yyg.yyin, YY_BUF_SIZE, yyg);
    }
    yyg.yy_buffer_stack[yyg.yy_buffer_stack_top].yy_at_bol = at_bol;
}

pub inline fn YY_AT_BOL(yyg: *yyguts_t) bool {
    if (yyg.yy_buffer_stack == null) return true;
    if (yyg.yy_buffer_stack[yyg.yy_buffer_stack_top] == null) return true;
    return yyg.yy_buffer_stack[yyg.yy_buffer_stack_top].?.yy_at_bol;
}

pub inline fn YY_AT_BOL_AS(comptime T: type, yyg: *yyguts_t) T {
    if (YY_AT_BOL(yyg)) {
        return @intCast(1);
    } else {
        return @intCast(0);
    }
}

// /* Begin user sect3 */

/// Done after the current pattern has been matched and before the
/// corresponding action - sets up yytext.
pub fn YY_DO_BEFORE_ACTION(yy_cp_: *[*c]u8, yy_bp_: *[*c]u8, yyg: *yyguts_t) void {
    const yy_cp: [*c]u8 = yy_cp_.*;
    const yy_bp: [*c]u8 = yy_bp_.*;
    yyg.yytext_r = yy_bp;
    yyg.yytext_r -= yyg.yy_more_len;
    yyg.yyleng_r = cPtrDistance(u8, yyg.yytext_r, yy_cp);
    yyg.yy_hold_char = yy_cp.*;
    yy_cp_.*.* = 0;
    yyg.yy_c_buf_p = yy_cp;
}

pub const YY_NUM_RULES = 13;
pub const YY_END_OF_BUFFER = 14;

// /* This struct is not used in this scanner,
//    but its presence is necessary. */
const yy_trans_info = struct {
    yy_verify: i32,
    yy_nxt: i32,
};
const yy_acclist: []const usize = &[56]usize{ 0, 9, 9, 11, 11, 6, 6, 14, 12, 13, 12, 13, 12, 13, 9, 12, 13, 10, 12, 13, 9, 12, 13, 11, 12, 13, 11, 12, 13, 6, 12, 13, 7, 12, 13, 6, 12, 13, 2, 5, 9, 9, 9, 11, 11, 6, 6, 6, 1, 3, 4, 9, 8, 1, 11, 6 };

const yy_accept: []const usize = &[47]usize{ 0, 1, 1, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 17, 20, 23, 26, 29, 32, 35, 38, 38, 38, 39, 39, 40, 40, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 49, 50, 50, 51, 52, 53, 55, 56, 56 };

const yy_ec: []const usize = &[256]usize{ 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 6, 1, 1, 7, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };

const yy_meta: []const usize = &[9]usize{ 0, 1, 1, 2, 1, 1, 1, 1, 1 };

const yy_base: []const usize = &[54]usize{ 0, 0, 0, 48, 2, 0, 46, 46, 4, 48, 52, 7, 7, 0, 52, 12, 0, 43, 0, 52, 16, 20, 23, 52, 19, 52, 25, 27, 0, 18, 29, 0, 15, 0, 14, 31, 52, 0, 52, 0, 52, 0, 52, 0, 0, 52, 34, 36, 38, 40, 42, 2, 44, 0 };

const yy_def: []const usize = &[54]usize{ 0, 46, 46, 47, 47, 48, 48, 49, 49, 45, 45, 50, 45, 51, 45, 51, 52, 52, 53, 45, 53, 50, 50, 45, 45, 45, 45, 45, 51, 51, 51, 52, 52, 53, 53, 53, 45, 26, 45, 27, 45, 30, 45, 52, 35, 0, 45, 45, 45, 45, 45, 45, 45, 45 };

const yy_nxt: []const usize = &[61]usize{ 0, 33, 11, 28, 12, 14, 15, 19, 20, 22, 23, 24, 25, 25, 26, 27, 29, 36, 43, 30, 34, 36, 36, 23, 35, 22, 23, 37, 38, 39, 40, 41, 42, 44, 40, 10, 10, 13, 13, 16, 16, 18, 18, 21, 21, 31, 31, 32, 45, 19, 17, 14, 9, 45, 45, 45, 45, 45, 45, 45, 45 };

const yy_chk: []const usize = &[61]usize{ 0, 53, 2, 51, 2, 4, 4, 8, 8, 11, 11, 12, 12, 12, 12, 12, 15, 34, 32, 15, 20, 29, 24, 21, 20, 22, 22, 26, 26, 27, 27, 30, 30, 35, 35, 46, 46, 47, 47, 48, 48, 49, 49, 50, 50, 52, 52, 17, 9, 7, 6, 3, 45, 45, 45, 45, 45, 45, 45, 45, 45 };

// /* Table of booleans, true if rule could match eol. */
const yy_rule_can_match_eol: []const usize = &[14]usize{
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    1,
    1,
    1,
    0,
};

pub fn REJECT(yyg: *yyguts_t, yy_cp_: *[*c]u8) void {
    yy_cp_.*.* = yyg.yy_hold_char; // undo effects of setting up yytext
    yy_cp_.* = yyg.yy_full_match; // restore poss. backed-over text
    yyg.yy_lp += 1;
    // TODO: really need a solution for this
    // goto find_rule;
    // loop_control = LOOP_START_YY_FIND_RULE;
    // continue;
}

pub fn yymore(yyg: *yyguts_t) void {
    yyg.yy_more_flag = 1;
}
// #define YY_MORE_ADJ yyg.yy_more_len
// #line 1 "flex.l"
// #line 9 "flex.l"
pub const Context = struct {
    pub const Error = error{
        LexSyntaxError,
    };

    pub const Section = enum {
        Definitions,
        Rules,
        UserCode,
    };
    pub const Loc = struct {
        line: usize = 0,
        col: usize = 0,
    };
    pub const CodeBlock = struct {
        allocator: std.mem.Allocator,
        content: std.ArrayList(u8),
        start: Loc = Loc{},
        end: Loc = Loc{},

        pub fn init(c: *const Context) CodeBlock {
            return CodeBlock{
                .allocator = c.allocator,
                .content = std.ArrayList(u8).init(c.allocator),
                .start = c.cur_loc,
                .end = c.cur_loc,
            };
        }

        pub fn reset(this: *CodeBlock, c: *const Context) void {
            this.content.clearAndFree();
            this.start = c.cur_loc;
            this.end = c.cur_loc;
        }

        pub fn isEmpty(this: *const CodeBlock) bool {
            return std.mem.trim(u8, this.content.items, " \t\r\n").len == 0;
        }

        pub fn countLines(this: *const CodeBlock) usize {
            var c: usize = 0;
            for (0..this.content.items.len) |i| {
                if (this.content.items[i] == '\n') c += 1;
            }
            return c;
        }

        pub fn lastLineCol(this: *const CodeBlock) usize {
            const maybe_last_newline_pos = std.mem.lastIndexOf(u8, this.content.items, "\n");
            if (maybe_last_newline_pos) |last_newline_pos| {
                return this.content.items.len - last_newline_pos - 1;
            } else {
                return this.content.items.len;
            }
        }
    };
    pub const StartConditionDefinitions = struct {
        names: std.ArrayList([]const u8),
        name_buf: std.ArrayList(u8),
        locs: std.ArrayList(Loc),

        pub fn init(allocator: std.mem.Allocator) StartConditionDefinitions {
            return StartConditionDefinitions{
                .names = std.ArrayList([]const u8).init(allocator),
                .name_buf = std.ArrayList(u8).init(allocator),
                .locs = std.ArrayList(Loc).init(allocator),
            };
        }

        pub fn deinit(this: *const StartConditionDefinitions) void {
            this.names.deinit();
            this.name_buf.deinit();
            this.locs.deinit();
        }
    };

    allocator: std.mem.Allocator,

    start_conditions: StartConditionDefinitions,
    definitions_cbs: std.ArrayList(CodeBlock),
    rules_cbs_1: std.ArrayList(CodeBlock),
    rules_action_cbs: std.ArrayList(CodeBlock),
    rules_cbs_2: std.ArrayList(CodeBlock),
    user_cbs: std.ArrayList(CodeBlock),

    cur_codeblock: CodeBlock = undefined,
    cur_section: Section = .Definitions,
    cur_loc: Loc = Loc{},
    last_sc: usize = INITIAL,

    pub fn init(allocator: std.mem.Allocator) Context {
        var c = Context{
            .allocator = allocator,
            .start_conditions = StartConditionDefinitions.init(allocator),
            .definitions_cbs = std.ArrayList(CodeBlock).init(allocator),
            .rules_cbs_1 = std.ArrayList(CodeBlock).init(allocator),
            .rules_action_cbs = std.ArrayList(CodeBlock).init(allocator),
            .rules_cbs_2 = std.ArrayList(CodeBlock).init(allocator),
            .user_cbs = std.ArrayList(CodeBlock).init(allocator),
        };
        c.start_conditions.name_buf.appendSlice("INITIAL") catch unreachable;
        c.start_conditions.names.append(c.start_conditions.name_buf.items[0..7]) catch unreachable;
        c.start_conditions.locs.append(.{ .line = 0, .col = 0 }) catch unreachable;
        c.cur_codeblock = Context.CodeBlock.init(&c);
        return c;
    }

    pub fn deinit(this: *const Context) void {
        this.start_conditions.deinit();
        this.definitions_cbs.deinit();
        this.rules_cbs_1.deinit();
        this.rules_action_cbs.deinit();
        this.rules_cbs_2.deinit();
        this.user_cbs.deinit();
    }
};

pub const ParserError = error{
    InlineCodeBlockInDefinitionSection,
    NoCodeBlockAllowed,
    InvalidStartCondition,
};

pub var context: Context = undefined;
// #line 459 "<stdout>"
// #line 136 "flex.l"
fn readRestLine(c: *Context, yyg: *yyguts_t) ![]u8 {
    var line_array = std.ArrayList(u8).init(c.allocator);
    defer line_array.deinit();
    var ch = try input(yyg);
    while (ch != 0 and ch != '\n') {
        try line_array.append(ch);
        ch = try input(yyg);
    }
    return line_array.toOwnedSlice();
}

fn findRulePatternStop(line: []const u8) ?usize {
    var i: usize = 0;
    var inside_class_braket: bool = false;
    while (i < line.len) {
        if ((i + 1) < line.len and line[i] == '\\' and line[i + 1] == ' ') {
            i += 2;
            continue;
        }
        if (line[i] == '[') inside_class_braket = true;
        if (line[i] == ']') inside_class_braket = false;
        //std.debug.print("\ncheck {d}, {c}, {any}\n", .{ i, line[i], inside_class_braket });
        if (inside_class_braket and line[i] == ' ') {
            i += 1;
            continue;
        }
        if (line[i] == ' ' or line[i] == '\t') return i;
        i += 1;
    }
    return null;
}

fn extractStartConditionName(line: []const u8) ![]const u8 {
    const s = std.mem.trim(u8, line, " \t\r\n");
    if (s.len == 0) return ParserError.InvalidStartCondition;
    return s;
}
// #line 498 "<stdout>"

// #line 500 "<stdout>"

pub const INITIAL = 0;
pub const rule = 1;
pub const user_block = 2;
pub const code_block = 3;

/// Holds the entire state of the reentrant scanner.
pub const yyguts_t = struct {
    lexer_: *Self = undefined,

    // User-defined. Type will be copied here, otherwise will be pointer to *anyopaque
    yyextra_r: *anyopaque,

    yyin_r: std.fs.File = undefined,
    yyout_r: std.fs.File = undefined,
    yy_buffer_stack_top: usize = 0, // *< index of top of stack.
    yy_buffer_stack_max: usize = 0, // *< capacity of stack.
    yy_buffer_stack: [*c]?*yy_buffer_state = 0, // /**< Stack as an array. */
    yy_hold_char: u8 = undefined,
    yy_n_chars: usize = 0,
    yyleng_r: usize = 0,
    yy_c_buf_p: [*c]u8 = 0,
    yy_init: bool = undefined,
    yy_start: usize = 0,
    yy_did_buffer_switch_on_eof: bool = undefined,
    yy_start_stack_ptr: usize = 0,
    yy_start_stack_depth: usize = 0,
    yy_start_stack: [*c]usize = 0,
    yy_last_accepting_state: usize = 0,
    yy_last_accepting_cpos: [*c]u8 = 0,

    yylineno_r: usize = 0,
    yycolumn_r: usize = 0,
    yy_flex_debug_r: bool = undefined,

    yy_state_buf: [*c]usize = 0,
    yy_state_ptr: [*c]usize = 0,
    yy_full_match: [*c]u8 = 0,
    yy_lp: usize = 0,

    // These are only needed for trailing context rules,
    // but there's no conditional variable for that yet.
    yy_looking_for_trail_begin: c_int = undefined,
    yy_full_lp: c_int = undefined,
    yy_full_state: [*c]c_int = 0,

    yytext_r: [*c]u8 = 0,
    yy_more_flag: bool = undefined,
    yy_more_len: usize = undefined,

    yylval_r: *YYSTYPE = undefined,

    yylloc_r: *YYLTYPE = undefined,

    // pub fn init(allocator: std.mem.Allocator) !yyguts_t {
    //    return yyguts_t{
    //        .yy_state_buf = try allocator.alloc(c_int, YY_STATE_BUF_SIZE),
    //        .yy_start = 1,
    //        .yyin = std.io.getStdIn(),
    //        .yyout = std.io.getStdOut(),
    //    };
    // }
};

/// Copy whatever the last rule matched to the standard output.
pub fn ECHO(yyg: *yyguts_t) !void {
    try yyg.yyout_r.writer().print("{s}", .{yyg.yytext_r[0..yyg.yyleng_r]});
}

// TODO:
/// Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
/// is returned in "result".
///
pub fn YY_INPUT(buf: [*c]u8, result: *usize, max_size: usize, yyg: *yyguts_t) !void {
    const yy_current_buffer = yyg.yy_buffer_stack[yyg.yy_buffer_stack_top];
    if (yy_current_buffer.?.yy_is_interactive) {
        var c: u8 = '*';
        var n: usize = 0;
        while (n < max_size) : (n += 1) {
            c = try yyg.yyin_r.reader().readByte();
            if (c == '\n') break;
        }
        buf[n] = c;
        if (c == '\n') {
            buf[n] = c;
            n += 1;
        }
        result.* = n;
    } else {
        result.* = try yyg.yyin_r.reader().read(buf[0..max_size]);
    }
}

// TODO: will this work?
// pub fn yyterminate(yyg: *yyguts_t) !void {
//    _ = yyg;
//    return error.YYTerminate;
// }

/// Number of entries by which start-condition stack grows.
pub const YY_START_STACK_INCR = 25;

pub fn YY_RULE_SETUP(this: *Self) !void {
    if (this.yyg.yyleng_r > 0) {
        this.yyg.yy_buffer_stack[this.yyg.yy_buffer_stack_top].?.yy_at_bol =
            (this.yyg.yytext_r[this.yyg.yyleng_r - 1] == '\n');
    }
    try YY_USER_ACTION(this);
}

/// The main scanner function which does all the work.
pub fn yylex(this: *Self, yylval_param: *YYSTYPE, yylloc_param: *YYLTYPE) !usize {
    var yy_cp: [*c]u8 = 0;
    var yy_bp: [*c]u8 = 0;
    var yy_act: usize = 0;
    var yyg = this.yyg;

    var yy_current_state: usize = 0;
    var yy_current_state_: *usize = &yy_current_state;
    _ = &yy_current_state_;

    // simulate goto with step&start - definition start
    const LOOP_STEP_YY_ACT = 0x0001;
    const LOOP_STEP_YY_FIND_RULE = 0x0002;
    const LOOP_STEP_YY_FIND_ACTION = 0x0004;
    const LOOP_STEP_YY_MATCH = 0x0008;
    const LOOP_STEP_INIT = 0x0010;

    const LOOP_START_YY_ACT = LOOP_STEP_YY_ACT;
    const LOOP_START_YY_FIND_RULE = LOOP_START_YY_ACT | LOOP_STEP_YY_FIND_RULE;
    const LOOP_START_YY_FIND_ACTION = LOOP_START_YY_FIND_RULE | LOOP_STEP_YY_FIND_ACTION;
    const LOOP_START_YY_MATCH = LOOP_START_YY_FIND_ACTION | LOOP_STEP_YY_MATCH;
    const LOOP_START_INIT = LOOP_START_YY_MATCH | LOOP_STEP_INIT;

    var loop_control: u16 = LOOP_START_INIT;
    // simulate goto with step&start - definition end

    var yylval: *YYSTYPE = yylval_param;
    {
        _ = &yylval;
    }

    var yylloc: *YYLTYPE = yylloc_param;
    {
        _ = &yylloc;
    }

    if (!yyg.yy_init) {
        yyg.yy_init = true;
        try YY_USER_INIT(this);

        // //
        // Create the reject buffer large enough to save one state per allowed character.
        if (yyg.yy_state_buf == null) {
            yyg.yy_state_buf = (try this.allocator.alloc(usize, YY_STATE_BUF_SIZE)).ptr;
        }
        //

        if (yyg.yy_start == 0) {
            yyg.yy_start = 1; // first start state
        }

        if (yyg.yy_buffer_stack == null or yyg.yy_buffer_stack[yyg.yy_buffer_stack_top] == null) {
            try yyensure_buffer_stack(yyg);
            const nb = try yy_create_buffer(yyg.yyin_r, YY_BUF_SIZE, yyg);
            yyg.yy_buffer_stack[yyg.yy_buffer_stack_top] = nb;
        }

        if (yyg.yy_buffer_stack[yyg.yy_buffer_stack_top] == null) {
            try yyensure_buffer_stack(yyg);
            yyg.yy_buffer_stack[yyg.yy_buffer_stack_top] = try yy_create_buffer(yyg.yyin_r, YY_BUF_SIZE, yyg);
        }

        yy_load_buffer_state(yyg);
    }

    // #line 179 "flex.l"

    // #line 680 "<stdout>"

    while (true) { // /* loops until end-of-file is reached */
        // LOOP_START_INIT
        if (loop_control & LOOP_STEP_INIT > 0) {
            // yymore()-related code
            yyg.yy_more_len = 0;
            if (yyg.yy_more_flag) {
                yyg.yy_more_len = cPtrDistance(u8, yyg.yytext_r, yyg.yy_c_buf_p);
                yyg.yy_more_flag = false;
            }

            yy_cp = yyg.yy_c_buf_p;

            // /* Support of yytext. */
            yy_cp.* = yyg.yy_hold_char;

            // /* yy_bp points to the position in yy_ch_buf of the start of
            // * the current run.
            // */
            yy_bp = yy_cp;

            // code to set up and find next match
            yy_current_state = yyg.yy_start;
            yy_current_state += YY_AT_BOL_AS(usize, yyg);

            yyg.yy_state_ptr = yyg.yy_state_buf;
            yyg.yy_state_ptr.* = yy_current_state;
            yyg.yy_state_ptr += 1;
        }

        // LOOP_START_YY_MATCH
        if (loop_control & LOOP_STEP_YY_MATCH > 0) {
            // yy_match:
            while (true) {
                var yy_c: usize = yy_ec[YY_SC_TO_UI(u8, yy_cp.*)];
                var c1 = yy_chk[yy_base[yy_current_state] + yy_c];
                while (c1 != yy_current_state) {
                    yy_current_state_.* = yy_def[yy_current_state];
                    if (yy_current_state >= 46)
                        yy_c = yy_meta[yy_c];
                    c1 = yy_chk[yy_base[yy_current_state] + yy_c];
                }
                yy_current_state_.* = yy_nxt[yy_base[yy_current_state] + yy_c];
                yyg.yy_state_ptr.* = yy_current_state;
                yyg.yy_state_ptr += 1;
                yy_cp += 1;
                if (yy_base[yy_current_state] == 52) break;
            }
        }

        // LOOP_START_YY_FIND_ACTION
        if (loop_control & LOOP_STEP_YY_FIND_ACTION > 0) {
            // yy_find_action:
            // code to find the action number
            yyg.yy_state_ptr -= 1;
            yy_current_state = yyg.yy_state_ptr.*;
            yyg.yy_lp = yy_accept[yy_current_state];
        }

        // LOOP_START_YY_FIND_RULE
        if (loop_control & LOOP_STEP_YY_FIND_RULE > 0) {
            // find_rule: // we branch to this label when backing up

            while (true) { // until we find what rule we matched
                if (yyg.yy_lp != 0 and yyg.yy_lp < yy_accept[yy_current_state + 1]) {
                    yy_act = yy_acclist[yyg.yy_lp];
                    {
                        yyg.yy_full_match = yy_cp;
                        break;
                    }
                }
                yy_cp -= 1;
                yyg.yy_state_ptr -= 1;
                yy_current_state = yyg.yy_state_ptr.*;
                yyg.yy_lp = yy_accept[yy_current_state];
            }

            YY_DO_BEFORE_ACTION(&yy_cp, &yy_bp, this.yyg);

            if (yy_act != YY_END_OF_BUFFER and yy_rule_can_match_eol[yy_act] != 0) {
                var yyl = yyg.yy_more_len;
                while (yyl < yyg.yyleng_r) : (yyl += 1) {
                    if (yyg.yytext_r[yyl] == '\n')
                        yyg.yylineno_r += 1;
                    yyg.yycolumn_r = 0;
                }
            }
        }

        // do_action: // This label is used only to access EOF actions.

        switch (yy_act) { // beginning of action switch
            1 => {
                yy_cp.* = yyg.yy_hold_char; // undo effects of setting up yytext
                yyg.yy_c_buf_p = yy_cp;
                yy_cp -= 1;
                YY_DO_BEFORE_ACTION(&yy_cp, &yy_bp, this.yyg); // set up yytext again
                try YY_RULE_SETUP(this);
                // #line 181 "flex.l"
                {
                    switch (context.cur_section) {
                        .Definitions => {
                            context.cur_codeblock.reset(&context);
                            context.cur_section = .Rules;
                            BEGIN(rule, yyg);
                        },
                        .Rules => {
                            if (!context.cur_codeblock.isEmpty()) {
                                try context.rules_action_cbs.append(context.cur_codeblock);
                                context.cur_codeblock = Context.CodeBlock.init(&context);
                            }
                            context.cur_section = .UserCode;
                            BEGIN(user_block, yyg);
                        },
                        else => {},
                    }
                    // std.debug.print("\nsection: {any}, line{d}\n", .{ parser.context.cur_section, parser.context.cur_loc.line });
                    context.cur_loc.col = yyg.yyleng_r;
                    // std.debug.print("now loc: line={d} col={d}\n", .{ parser.context.cur_loc.line, parser.context.cur_loc.col });
                }
            },
            2 => {
                yy_cp.* = yyg.yy_hold_char; // undo effects of setting up yytext
                yyg.yy_c_buf_p = yy_cp;
                yy_cp -= 1;
                YY_DO_BEFORE_ACTION(&yy_cp, &yy_bp, this.yyg); // set up yytext again
                try YY_RULE_SETUP(this);
                // #line 203 "flex.l"
                {
                    context.cur_codeblock.start = .{
                        .line = context.cur_loc.line,
                        .col = 0,
                    };
                    context.cur_codeblock.end = .{
                        .line = context.cur_loc.line,
                        .col = yyg.yyleng_r,
                    };
                    try context.cur_codeblock.content.appendSlice(yyg.yytext_r[0..yyg.yyleng_r]);

                    switch (context.cur_section) {
                        .Definitions => {
                            try context.definitions_cbs.append(context.cur_codeblock);
                        },
                        .Rules => {
                            return ParserError.InlineCodeBlockInDefinitionSection;
                        },
                        else => {},
                    }

                    // std.debug.print("code block inline:{s} {d},{d}\n", .{ parser.yy.text[0..parser.yy.leng], parser.context.cur_loc.line, parser.context.cur_loc.col });

                    context.cur_loc.col = yyg.yyleng_r;
                    // std.debug.print("now loc: line={d} col={d}\n", .{ parser.context.cur_loc.line, parser.context.cur_loc.col });
                    context.cur_codeblock = Context.CodeBlock.init(&context);
                }
            },
            3 => {
                yy_cp.* = yyg.yy_hold_char; // undo effects of setting up yytext
                yyg.yy_c_buf_p = yy_cp;
                yy_cp -= 1;
                YY_DO_BEFORE_ACTION(&yy_cp, &yy_bp, this.yyg); // set up yytext again
                try YY_RULE_SETUP(this);
                // #line 231 "flex.l"
                {
                    switch (context.cur_section) {
                        .Definitions => {
                            context.last_sc = INITIAL;
                        },
                        .Rules => {
                            if (!context.cur_codeblock.isEmpty()) {
                                try context.rules_action_cbs.append(context.cur_codeblock);
                                context.cur_codeblock = Context.CodeBlock.init(&context);
                            }
                            context.last_sc = rule;
                        },
                        else => {
                            return ParserError.NoCodeBlockAllowed;
                        },
                    }
                    BEGIN(code_block, yyg);

                    // std.debug.print("code block start:{s}\n", .{parser.yy.text[0..parser.yy.leng]});
                    context.cur_codeblock.start.line = context.cur_loc.line;
                    context.cur_codeblock.start.col = yyg.yyleng_r;
                    context.cur_loc.col = yyg.yyleng_r;
                    // std.debug.print("now loc: line={d} col={d}\n", .{ parser.context.cur_loc.line, parser.context.cur_loc.col });
                }
            },
            4 => {
                yy_cp.* = yyg.yy_hold_char; // undo effects of setting up yytext
                yyg.yy_c_buf_p = yy_cp;
                yy_cp -= 1;
                YY_DO_BEFORE_ACTION(&yy_cp, &yy_bp, this.yyg); // set up yytext again
                try YY_RULE_SETUP(this);
                // #line 256 "flex.l"
                {
                    switch (context.cur_section) {
                        .Definitions => {
                            try context.definitions_cbs.append(context.cur_codeblock);
                        },
                        .Rules => {
                            if (context.rules_action_cbs.items.len > 0) {
                                try context.rules_cbs_2.append(context.cur_codeblock);
                            } else {
                                try context.rules_cbs_1.append(context.cur_codeblock);
                            }
                        },
                        else => {
                            return ParserError.NoCodeBlockAllowed;
                        },
                    }

                    // std.debug.print("code block stop:{s}\n", .{parser.yy.text[0..parser.yy.leng]});
                    BEGIN(context.last_sc, yyg);

                    context.cur_loc.col = yyg.yyleng_r;
                    // std.debug.print("now loc: line={d} col={d}\n", .{ parser.context.cur_loc.line, parser.context.cur_loc.col });
                    context.cur_codeblock = Context.CodeBlock.init(&context);
                }
            },
            5 => {
                try YY_RULE_SETUP(this);
                // #line 281 "flex.l"
                {
                    // std.debug.print("now loc: line={d} col={d}\n", .{ context.cur_loc.col });
                    const line = try readRestLine(&context, yyg);
                    const condition_name = try extractStartConditionName(line);
                    // std.debug.print("start condition line: {s}, {s}\n", .{ line, condition_name });
                    const s = context.start_conditions.name_buf.items.len;
                    try context.start_conditions.name_buf.appendSlice(condition_name);
                    const e = context.start_conditions.name_buf.items.len;
                    try context.start_conditions.names.append(context.start_conditions.name_buf.items[s..e]);
                    try context.start_conditions.locs.append(context.cur_loc);
                    // std.debug.print("start condition line: {s}, {s}, {d}\n", .{ line, condition_name, context.start_conditions.names.items.len });
                    context.cur_loc.line += 1;
                    context.cur_loc.col = 0;
                    // std.debug.print("now loc: line={d} col={d}\n", .{ context.cur_loc.line, context.cur_loc.col });
                }
            },
            6 => {
                try YY_RULE_SETUP(this);
                // #line 297 "flex.l"
                {
                    try context.cur_codeblock.content.appendSlice(yyg.yytext_r[0..yyg.yyleng_r]);
                    context.cur_codeblock.end.line = context.cur_loc.line;
                    context.cur_codeblock.end.col = yyg.yyleng_r;
                    // std.debug.print("code block content:{s}\n", .{parser.yy.text[0..parser.yy.leng]});
                    context.cur_loc.col += yyg.yyleng_r;
                    // std.debug.print("now loc: line={d} col={d}\n", .{ parser.context.cur_loc.line, parser.context.cur_loc.col });
                }
            },
            7 => {
                // /* rule 7 can match eol */
                try YY_RULE_SETUP(this);
                // #line 306 "flex.l"
                {
                    try context.cur_codeblock.content.appendSlice(yyg.yytext_r[0..yyg.yyleng_r]);
                    context.cur_codeblock.end.line = context.cur_loc.line;
                    context.cur_codeblock.end.col = yyg.yyleng_r;
                    // std.debug.print("code block content:{s}\n", .{parser.yy.text[0..parser.yy.leng]});
                    context.cur_loc.col += yyg.yyleng_r;
                    // std.debug.print("now loc: line={d} col={d}\n", .{ parser.context.cur_loc.line, parser.context.cur_loc.col });
                }
            },
            8 => {
                yy_cp.* = yyg.yy_hold_char; // undo effects of setting up yytext
                yyg.yy_c_buf_p = yy_cp;
                yy_cp -= 1;
                YY_DO_BEFORE_ACTION(&yy_cp, &yy_bp, this.yyg); // set up yytext again
                try YY_RULE_SETUP(this);
                // #line 315 "flex.l"
                {
                    switch (context.cur_section) {
                        .Definitions => {
                            context.last_sc = INITIAL;
                        },
                        .Rules => {
                            if (!context.cur_codeblock.isEmpty()) {
                                try context.rules_action_cbs.append(context.cur_codeblock);
                                context.cur_codeblock = Context.CodeBlock.init(&context);
                            }
                            context.last_sc = rule;
                        },
                        else => {
                            return ParserError.NoCodeBlockAllowed;
                        },
                    }
                    BEGIN(code_block, yyg);

                    // std.debug.print("code block start:{s}\n", .{parser.yy.text[0..parser.yy.leng]});
                    context.cur_codeblock.start.line = context.cur_loc.line;
                    context.cur_codeblock.start.col = yyg.yyleng_r;
                    context.cur_loc.col = yyg.yyleng_r;
                    // std.debug.print("now loc: line={d} col={d}\n", .{ parser.context.cur_loc.line, parser.context.cur_loc.c  }
                }
            },
            9 => {
                try YY_RULE_SETUP(this);
                // #line 340 "flex.l"
                {
                    const line = yyg.yytext_r[0..yyg.yyleng_r];
                    const maybe_pattern_stop = findRulePatternStop(line);
                    if (maybe_pattern_stop) |pattern_stop| {
                        if (pattern_stop == 0) {
                            //std.debug.print("rule action line:{s}, {d},{d}\n", .{ line, parser.context.cur_loc.line, parser.context.cur_loc.col });
                            try context.cur_codeblock.content.appendSlice(line);
                            context.cur_codeblock.end.line = context.cur_loc.line;
                            context.cur_codeblock.end.col = yyg.yyleng_r;
                        } else {
                            const trimed_action_line = std.mem.trimLeft(u8, line[pattern_stop..], " \t");
                            const action_line_start = line.len - trimed_action_line.len + 1;
                            // std.debug.print("action_line_start: {d}\n", .{action_line_start});
                            if (!context.cur_codeblock.isEmpty()) {
                                // std.debug.print("append last cur_codeblock: {d},{any}\n", .{ parser.context.cur_codeblock.content.items.len, parser.context.cur_codeblock.content.items });
                                try context.rules_action_cbs.append(context.cur_codeblock);
                                context.cur_codeblock = Context.CodeBlock.init(&context);
                                context.cur_codeblock.start.col = action_line_start;
                            }
                            // std.debug.print("rule pattern with action:{s},{s}, {d},{d} {d},{d}\n", .{ line[0..pattern_stop], line[pattern_stop..], parser.context.cur_loc.line, parser.context.cur_loc.col, parser.context.cur_codeblock.start.line, parser.context.cur_codeblock.start.col });
                            context.cur_codeblock.content.clearAndFree();
                            try context.cur_codeblock.content.appendSlice(trimed_action_line);
                            context.cur_codeblock.start = .{
                                .line = context.cur_loc.line,
                                .col = action_line_start,
                            };
                            context.cur_codeblock.end = .{
                                .line = context.cur_loc.line,
                                .col = line.len,
                            };
                        }
                    } else {
                        if (!context.cur_codeblock.isEmpty()) {
                            // std.debug.print("append last cur_codeblock: {d},{any}\n", .{ parser.context.cur_codeblock.content.items.len, parser.context.cur_codeblock.content.items });
                            try context.rules_action_cbs.append(context.cur_codeblock);
                            context.cur_codeblock = Context.CodeBlock.init(&context);
                        }
                        // std.debug.print("rule pattern without action:{s}, {d},{d} {d},{d}\n", .{ line, parser.context.cur_loc.line, parser.context.cur_loc.col, parser.context.cur_codeblock.start.line, parser.context.cur_codeblock.start.col });
                    }

                    // std.debug.print("rule line:{s}, {d},{d}\n", .{ line, parser.context.cur_loc.line, parser.context.cur_loc.col });
                    context.cur_loc.col = yyg.yyleng_r;
                    // std.debug.print("now loc: line={d} col={d}\n", .{ parser.context.cur_loc.line, parser.context.cur_loc.col });
                }
            },
            10 => {
                // /* rule 10 can match eol */
                try YY_RULE_SETUP(this);
                // #line 386 "flex.l"
                {
                    try context.cur_codeblock.content.append('\n');
                    // std.debug.print("rule new line:\n", .{});
                    context.cur_loc.line += 1;
                    context.cur_loc.col = 0;
                    // std.debug.print("now loc: line={d} col={d}\n", .{ parser.context.cur_loc.line, parser.context.cur_loc.col });
                }
            },
            11 => {
                // /* rule 11 can match eol */
                try YY_RULE_SETUP(this);
                // #line 394 "flex.l"
                {}
            },
            12 => {
                // /* rule 12 can match eol */
                try YY_RULE_SETUP(this);
                // #line 396 "flex.l"
                {
                    if (yyg.yyleng_r == 1 and yyg.yytext_r[0] == '\n') {
                        context.cur_loc.line += 1;
                        context.cur_loc.col = 0;
                    } else {
                        context.cur_loc.col += 1;
                    }
                    // std.debug.print("default now loc: line={d} col={d}\n", .{ parser.context.cur_loc.line, parser.context.cur_loc.col });
                }
            },
            13 => {
                try YY_RULE_SETUP(this);
                // #line 406 "flex.l"
                try ECHO(yyg);
            },
            // #line 1070 "<stdout>"
            YY_STATE_EOF(INITIAL) => {
                return YY_TERMINATED;
            },

            YY_STATE_EOF(rule) => {
                return YY_TERMINATED;
            },

            YY_STATE_EOF(user_block) => {
                return YY_TERMINATED;
            },

            YY_STATE_EOF(code_block) => {
                return YY_TERMINATED;
            },

            YY_END_OF_BUFFER => {
                // Amount of text matched not including the EOB char.
                const yy_amount_of_matched_text = cPtrDistance(u8, yyg.yytext_r, yy_cp) - 1;

                // Undo the effects of YY_DO_BEFORE_ACTION.
                yy_cp.* = yyg.yy_hold_char;

                if (yyg.yy_buffer_stack[yyg.yy_buffer_stack_top].?.yy_buffer_status == yy_buffer_state.YY_BUFFER_NEW) {
                    // We're scanning a new file or input source.  It's
                    // possible that this happened because the user
                    // just pointed yyin at a new source and called
                    // yylex().  If so, then we have to assure
                    // consistency between YY_CURRENT_BUFFER and our
                    // globals.  Here is the right place to do so, because
                    // this is the first action (other than possibly a
                    // back-up) that will match for the new input source.
                    //
                    yyg.yy_n_chars = yyg.yy_buffer_stack[yyg.yy_buffer_stack_top].?.yy_n_chars;
                    yyg.yy_buffer_stack[yyg.yy_buffer_stack_top].?.yy_input_file = yyg.yyin_r;
                    yyg.yy_buffer_stack[yyg.yy_buffer_stack_top].?.yy_buffer_status = yy_buffer_state.YY_BUFFER_NORMAL;
                }

                // Note that here we test for yy_c_buf_p "<=" to the position
                // of the first EOB in the buffer, since yy_c_buf_p will
                // already have been incremented past the NUL character
                // (since all states make transitions on EOB to the
                // end-of-buffer state).  Contrast this with the test
                // in input().
                //
                if (yyg.yy_c_buf_p <= yyg.yy_buffer_stack[yyg.yy_buffer_stack_top].?.yy_ch_buf[yyg.yy_n_chars]) {
                    // This was really a NUL.
                    var yy_next_state: usize = undefined;

                    yyg.yy_c_buf_p = yyg.yytext_r + yy_amount_of_matched_text;

                    yy_current_state = yy_get_previous_state(yyg);

                    // Okay, we're now positioned to make the NUL
                    // transition.  We couldn't have
                    // yy_get_previous_state() go ahead and do it
                    // for us because it doesn't know how to deal
                    // with the possibility of jamming (and we don't
                    // want to build jamming into it because then it
                    // will run more slowly).
                    //

                    yy_next_state = yy_try_NUL_trans(&yy_current_state, yyg);

                    yy_bp = yyg.yytext_r + yyg.yy_more_len;

                    if (yy_next_state != 0) {
                        // /* Consume the NUL. */
                        yyg.yy_c_buf_p = yyg.yy_c_buf_p + 1;
                        yy_cp = yyg.yy_c_buf_p;
                        yy_current_state = yy_next_state;

                        // break :yy_match;
                        loop_control = LOOP_START_YY_MATCH;
                        continue;
                    } else {
                        yy_cp = yyg.yy_c_buf_p;
                        // break :yy_find_action;
                        loop_control = LOOP_START_YY_FIND_ACTION;
                        continue;
                    }
                } else switch (try yy_get_next_buffer(yyg)) {
                    EOB_ACT_END_OF_FILE => {
                        yyg.yy_did_buffer_switch_on_eof = false;

                        if (yywrap(yyg) != 0) {
                            // Note: because we've taken care in
                            // yy_get_next_buffer() to have set up
                            // yytext, we can now set up
                            // yy_c_buf_p so that if some total
                            // hoser (like flex itself) wants to
                            // call the scanner after we return the
                            // YY_NULL, it'll still work - another
                            // YY_NULL will get returned.
                            //
                            yyg.yy_c_buf_p = yyg.yytext_r + yyg.yy_more_len;

                            yy_act = YY_STATE_EOF(YY_START(yyg));
                            // break :do_action;
                            loop_control = LOOP_START_YY_ACT;
                            continue;
                        } else {
                            if (!yyg.yy_did_buffer_switch_on_eof)
                                try YY_NEW_FILE(yyg);
                        }
                    },

                    EOB_ACT_CONTINUE_SCAN => {
                        yyg.yy_c_buf_p =
                            yyg.yytext_r + yy_amount_of_matched_text;

                        yy_current_state = yy_get_previous_state(yyg);

                        yy_cp = yyg.yy_c_buf_p;
                        yy_bp = yyg.yytext_r + yyg.yy_more_len;

                        // break :yy_match;
                        loop_control = LOOP_START_YY_MATCH;
                        continue;
                    },

                    EOB_ACT_LAST_MATCH => {
                        yyg.yy_c_buf_p =
                            yyg.yy_buffer_stack[yyg.yy_buffer_stack_top].?.yy_ch_buf[yyg.yy_n_chars];

                        yy_current_state = yy_get_previous_state(yyg);

                        yy_cp = yyg.yy_c_buf_p;
                        yy_bp = yyg.yytext_r + yyg.yy_more_len;

                        // break :yy_find_action;
                        loop_control = LOOP_START_YY_FIND_ACTION;
                        continue;
                    },

                    else => {},
                }
            },

            else => {
                yy_fatal_error("fatal flex scanner internal error--no action found");
            },
        } // end of switch

        loop_control = LOOP_START_INIT;
    } // end_of_file loop

    return YY_TERMINATED;
} // end of yylex

///  yy_get_next_buffer - try to read in a new buffer
///
///  Returns a code representing an action:
/// 	EOB_ACT_LAST_MATCH -
/// 	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
/// 	EOB_ACT_END_OF_FILE - end of file
///
pub fn yy_get_next_buffer(yyg: *yyguts_t) !usize {
    var yy_current_buffer = yyg.yy_buffer_stack[yyg.yy_buffer_stack_top].?;
    var dest = yy_current_buffer.yy_ch_buf;
    var source = yyg.yytext_r;
    var number_to_move: usize = undefined;
    var ret_val: usize = undefined;

    if (yyg.yy_c_buf_p > &(yy_current_buffer.yy_ch_buf[yyg.yy_n_chars + 1])) {
        yy_fatal_error("fatal flex scanner internal error--end of buffer missed");
    }

    if (!yy_current_buffer.yy_fill_buffer) {
        // Don't try to fill the buffer, so this is an EOF.
        if (cPtrDistance(u8, yyg.yytext_r, yyg.yy_c_buf_p) - yyg.yy_more_len == 1) {
            // We matched a single character, the EOB, so
            // treat this as a final EOF.
            //
            return EOB_ACT_END_OF_FILE;
        } else {
            // We matched some text prior to the EOB, first
            // process it.
            //
            return EOB_ACT_LAST_MATCH;
        }
    }

    // Try to read more data.

    // First move last chars to start of buffer.
    number_to_move = cPtrDistance(u8, yyg.yytext_r, yyg.yy_c_buf_p) - 1;

    for (0..number_to_move) |_| {
        // TODO: right?
        dest.* = source.*;
        dest += 1;
        source += 1;
    }

    if (yy_current_buffer.yy_buffer_status == yy_buffer_state.YY_BUFFER_EOF_PENDING) {
        // don't do the read, it's not guaranteed to return an EOF,
        // just force an EOF
        //
        yyg.yy_n_chars = 0;
        yy_current_buffer.yy_n_chars = 0;
    } else {
        var num_to_read: usize = yy_current_buffer.yy_buf_size - number_to_move - 1;

        if (num_to_read <= 0) {
            // /* Not enough room in the buffer - grow it. */

            yy_fatal_error("input buffer overflow, can't enlarge buffer because scanner uses REJECT");
        }

        if (num_to_read > YY_READ_BUF_SIZE) num_to_read = YY_READ_BUF_SIZE;

        // Read in more data.
        try YY_INPUT(yy_current_buffer.yy_ch_buf[number_to_move], &yyg.yy_n_chars, num_to_read, yyg);

        yy_current_buffer.yy_n_chars = yyg.yy_n_chars;
    }

    if (yyg.yy_n_chars == 0) {
        if (number_to_move == yyg.yy_more_len) {
            ret_val = EOB_ACT_END_OF_FILE;
            try yyrestart(yyg.yyin_r, yyg);
        } else {
            ret_val = EOB_ACT_LAST_MATCH;
            yy_current_buffer.yy_buffer_status = yy_buffer_state.YY_BUFFER_EOF_PENDING;
        }
    } else ret_val = EOB_ACT_CONTINUE_SCAN;

    if ((yyg.yy_n_chars + number_to_move) > yy_current_buffer.yy_buf_size) {
        // Extend the array by 50%, plus the number we really need.
        const new_size: usize = yyg.yy_n_chars + number_to_move + (yyg.yy_n_chars >> 1);
        yy_current_buffer.yy_ch_buf = (try yyg.lexer_.allocator.realloc(yy_current_buffer.yy_ch_buf[0..yyg.yy_n_chars], new_size)).ptr;
        // - 2 to take care of EOB's
        yy_current_buffer.yy_buf_size = new_size - 2;
    }

    yyg.yy_n_chars += number_to_move;
    yy_current_buffer.yy_ch_buf[yyg.yy_n_chars] = YY_END_OF_BUFFER_CHAR;
    yy_current_buffer.yy_ch_buf[yyg.yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

    yyg.yytext_r = &(yy_current_buffer.yy_ch_buf[0]);

    return ret_val;
}

/// yy_get_previous_state - get the state just before the EOB char was reached */
pub fn yy_get_previous_state(yyg: *yyguts_t) usize {
    var yy_current_state: usize = 0;
    var yy_cp: [*c]u8 = 0;
    const yy_current_state_ = &yy_current_state;

    yy_current_state = yyg.yy_start;
    yy_current_state += YY_AT_BOL_AS(usize, yyg);

    yyg.yy_state_ptr = yyg.yy_state_buf;
    yyg.yy_state_ptr.* = yy_current_state;
    yyg.yy_state_ptr += 1;

    yy_cp = yyg.yytext_r + yyg.yy_more_len;
    while (yy_cp < yyg.yy_c_buf_p) : (yy_cp = yy_cp + 1) {
        var yy_c: usize = if (yy_cp.* == 0) yy_ec[YY_SC_TO_UI(u8, yy_cp.*)] else 1;
        var c1 = yy_chk[yy_base[yy_current_state] + yy_c];
        while (c1 != yy_current_state) {
            yy_current_state_.* = yy_def[yy_current_state];
            if (yy_current_state >= 46)
                yy_c = yy_meta[yy_c];
            c1 = yy_chk[yy_base[yy_current_state] + yy_c];
        }
        yy_current_state_.* = yy_nxt[yy_base[yy_current_state] + yy_c];
        yyg.yy_state_ptr.* = yy_current_state;
        yyg.yy_state_ptr += 1;
    }

    return yy_current_state;
}

/// yy_try_NUL_trans - try to make a transition on the NUL character
///
/// synopsis
///	next_state = yy_try_NUL_trans( current_state );
///
pub fn yy_try_NUL_trans(yy_current_state_: *usize, yyg: *yyguts_t) usize {
    var yy_is_jam: bool = undefined;
    const yy_current_state = yy_current_state_.*;

    var yy_c: usize = 1;
    var c1 = yy_chk[yy_base[yy_current_state] + yy_c];
    while (c1 != yy_current_state) {
        yy_current_state_.* = yy_def[yy_current_state];
        if (yy_current_state >= 46)
            yy_c = yy_meta[yy_c];
        c1 = yy_chk[yy_base[yy_current_state] + yy_c];
    }
    yy_current_state_.* = yy_nxt[yy_base[yy_current_state] + yy_c];
    yy_is_jam = (yy_current_state_.* == 45);
    if (!yy_is_jam)
        yyg.yy_state_ptr.* = yy_current_state_.*;
    yyg.yy_state_ptr += 1;

    return if (yy_is_jam) 0 else yy_current_state_.*;
}

pub fn yyunput(c: u8, yy_bp: [*c]u8, yyg: *yyguts_t) void {
    var yy_current_buffer = yyg.yy_buffer_stack[yyg.yy_buffer_stack_top];
    var yy_cp: [*c]u8 = yyg.yy_c_buf_p;

    // undo effects of setting up yytext
    yy_cp.* = yyg.yy_hold_char;

    if (yy_cp < yy_current_buffer.yy_ch_buf + 2) { // need to shift things up to make room
        // +2 for EOB chars.
        const number_to_move: usize = yyg.yy_n_chars + 2;
        var dest = &yy_current_buffer.yy_ch_buf[yy_current_buffer.yy_buf_size + 2];
        var source = &yy_current_buffer.yy_ch_buf[number_to_move];

        while (source > yy_current_buffer.yy_ch_buf) {
            dest -= 1;
            source -= 1;
            dest.* = source.*;
        }

        yy_cp += (dest - source);
        yy_bp += (dest - source);
        yy_current_buffer.yy_n_chars = yy_current_buffer.yy_buf_size;
        yyg.yy_n_chars = yy_current_buffer.yy_buf_size;

        if (yy_cp < yy_current_buffer.yy_ch_buf + 2)
            yy_fatal_error("flex scanner push-back overflow");
    }

    yy_cp -= 1;
    yy_cp.* = c;

    if (c == '\n') {
        yyg.yylineno -= 1;
    }

    yyg.yytext_r = yy_bp;
    yyg.yy_hold_char = yy_cp.*;
    yyg.yy_c_buf_p = yy_cp;
}

pub fn input(yyg: *yyguts_t) !u8 {
    var yy_current_buffer = yyg.yy_buffer_stack[yyg.yy_buffer_stack_top];
    var c: u8 = undefined;

    yyg.yy_c_buf_p.* = yyg.yy_hold_char;

    if (yyg.yy_c_buf_p.* == YY_END_OF_BUFFER_CHAR) {
        // yy_c_buf_p now points to the character we want to return.
        // If this occurs *before* the EOB characters, then it's a
        // valid NUL; if not, then we've hit the end of the buffer.
        //
        if (yyg.yy_c_buf_p < &yy_current_buffer.?.yy_ch_buf[yyg.yy_n_chars]) {
            // This was really a NUL.
            yyg.yy_c_buf_p.* = 0;
        } else {
            // need more input
            const offset: usize = cPtrDistance(u8, yyg.yytext_r, yyg.yy_c_buf_p);
            yyg.yy_c_buf_p += 1;

            const nb = try yy_get_next_buffer(yyg);
            switch (nb) {
                EOB_ACT_LAST_MATCH, EOB_ACT_END_OF_FILE => {
                    // This happens because yy_g_n_b()
                    // sees that we've accumulated a
                    // token and flags that we need to
                    // try matching the token before
                    // proceeding.  But for input(),
                    // there's no matching to consider.
                    // So convert the EOB_ACT_LAST_MATCH
                    // to EOB_ACT_END_OF_FILE.
                    //

                    if (nb == EOB_ACT_LAST_MATCH) {
                        // Reset buffer status.
                        try yyrestart(yyg.yyin_r, yyg);
                    }

                    if (yywrap(yyg) != 0)
                        return 0;

                    if (!yyg.yy_did_buffer_switch_on_eof)
                        try YY_NEW_FILE(yyg);
                    return input(yyg);
                },

                EOB_ACT_CONTINUE_SCAN => {
                    yyg.yy_c_buf_p = yyg.yytext_r + offset;
                },

                else => {},
            }
        }
    }

    c = yyg.yy_c_buf_p.*; // cast for 8-bit char's
    yyg.yy_c_buf_p.* = 0; // preserve yytext
    yyg.yy_c_buf_p += 1;
    yyg.yy_hold_char = yyg.yy_c_buf_p.*;

    yyg.yy_buffer_stack[yyg.yy_buffer_stack_top].?.yy_at_bol = (c == '\n');
    if (yyg.yy_buffer_stack[yyg.yy_buffer_stack_top].?.yy_at_bol)
        yyg.yylineno_r += 1;
    yyg.yycolumn_r = 0;

    return c;
}

/// Immediately switch to a different input stream.
/// @param input_file A readable stream.
/// @note This function does not reset the start condition to @c INITIAL .
///
pub fn yyrestart(input_file: std.fs.File, yyg: *yyguts_t) !void {
    var yy_current_buffer = yyg.yy_buffer_stack[yyg.yy_buffer_stack_top];
    if (yy_current_buffer == null) {
        try yyensure_buffer_stack(yyg);
        yyg.yy_buffer_stack[yyg.yy_buffer_stack_top] = try yy_create_buffer(yyg.yyin_r, YY_BUF_SIZE, yyg);
        yy_current_buffer = yyg.yy_buffer_stack[yyg.yy_buffer_stack_top];
    }
    yy_init_buffer(yy_current_buffer.?, input_file, yyg);
    yy_load_buffer_state(yyg);
}

/// Switch to a different input buffer.
///  @param new_buffer The new input buffer.
///
pub fn yy_switch_to_buffer(new_buffer: *yy_buffer_state, yyg: *yyguts_t) !void {
    yypop_buffer_state(yyg);
    try yypush_buffer_state(new_buffer, yyg);
}

pub fn yy_load_buffer_state(yyg: *yyguts_t) void {
    const yy_current_buffer = yyg.yy_buffer_stack[yyg.yy_buffer_stack_top].?;
    yyg.yy_n_chars = yy_current_buffer.yy_n_chars;
    yyg.yytext_r = yy_current_buffer.yy_buf_pos;
    yyg.yy_c_buf_p = yy_current_buffer.yy_buf_pos;
    yyg.yyin_r = yy_current_buffer.yy_input_file;
    yyg.yy_hold_char = yyg.yy_c_buf_p.*;
}

/// Allocate and initialize an input buffer state.
/// @param file A readable stream.
/// @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
/// @return the allocated buffer state.
///
pub fn yy_create_buffer(file: std.fs.File, size: usize, yyg: *yyguts_t) !*yy_buffer_state {
    var b: *yy_buffer_state = try createZero(yyg.lexer_.allocator, yy_buffer_state);
    b.yy_buf_size = size;

    // yy_ch_buf has to be 2 characters longer than the size given because
    // we need to put in 2 end-of-buffer characters.
    //
    b.yy_ch_buf = (try yyg.lexer_.allocator.alloc(u8, b.yy_buf_size + 2)).ptr;
    b.yy_is_our_buffer = true;
    yy_init_buffer(b, file, yyg);

    return b;
}

/// Destroy the buffer.
/// @param b a buffer created with yy_create_buffer()
///
pub fn yy_delete_buffer(b: *yy_buffer_state, yyg: *yyguts_t) void {
    var yy_current_buffer = yyg.yy_buffer_stack[yyg.yy_buffer_stack_top];

    // if ( ! b )
    //	return;

    if (b == yy_current_buffer) // Not sure if we should pop here.
        yy_current_buffer = null;

    if (b.yy_is_our_buffer) {
        yyg.lexer_.allocator.free(b.yy_ch_buf[0..b.yy_n_chars]);
    }

    yyg.lexer_.allocator.destroy(b);
}

/// Initializes or reinitializes a buffer.
/// This function is sometimes called more than once on the same buffer,
/// such as during a yyrestart() or at EOF.
///
pub fn yy_init_buffer(b: *yy_buffer_state, file: std.fs.File, yyg: *yyguts_t) void {
    yy_flush_buffer(b, yyg);
    const yy_current_buffer = yyg.yy_buffer_stack[yyg.yy_buffer_stack_top];

    b.yy_input_file = file;
    b.yy_fill_buffer = true;

    // If b is the current buffer, then yy_init_buffer was _probably_
    // called from yyrestart() or through yy_get_next_buffer.
    // In that case, we don't want to reset the lineno or column.
    //
    if (b != yy_current_buffer) {
        b.yy_bs_lineno = 1;
        b.yy_bs_column = 0;
    }

    b.yy_is_interactive = file.handle > 0;
}

/// Discard all buffered characters. On the next scan, YY_INPUT will be called.
/// @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
///
pub fn yy_flush_buffer(b: *yy_buffer_state, yyg: *yyguts_t) void {
    const yy_current_buffer = yyg.yy_buffer_stack[yyg.yy_buffer_stack_top];
    // if ( ! b )
    // 	return;

    b.yy_n_chars = 0;

    // /* We always need two end-of-buffer characters.  The first causes
    //  * a transition to the end-of-buffer state.  The second causes
    //  * a jam in that state.
    //  */
    b.yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
    b.yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

    b.yy_buf_pos = &b.yy_ch_buf[0];

    b.yy_at_bol = true;
    b.yy_buffer_status = yy_buffer_state.YY_BUFFER_NEW;

    if (b == yy_current_buffer) yy_load_buffer_state(yyg);
}

/// Pushes the new state onto the stack. The new state becomes
/// the current state. This function will allocate the stack
/// if necessary.
/// @param new_buffer The new state.
///
pub fn yypush_buffer_state(new_buffer: *yy_buffer_state, yyg: *yyguts_t) !void {
    // if (new_buffer == NULL)
    //	return;

    try yyensure_buffer_stack(yyg);

    var yy_current_buffer = yyg.yy_buffer_stack[yyg.yy_buffer_stack_top];

    // This block is copied from yy_switch_to_buffer.
    if (yy_current_buffer != null) {
        // Flush out information for old buffer.
        yyg.yy_c_buf_p.* = yyg.yy_hold_char;
        yy_current_buffer.?.yy_buf_pos = yyg.yy_c_buf_p;
        yy_current_buffer.?.yy_n_chars = yyg.yy_n_chars;
    }

    // Only push if top exists. Otherwise, replace top.
    if (yy_current_buffer != null) {
        yyg.yy_buffer_stack_top += 1;
    }
    yyg.yy_buffer_stack[yyg.yy_buffer_stack_top] = new_buffer;

    // copied from yy_switch_to_buffer.
    yy_load_buffer_state(yyg);
    yyg.yy_did_buffer_switch_on_eof = true;
}

/// Removes and deletes the top of the stack, if present.
/// The next element becomes the new top.
///
pub fn yypop_buffer_state(yyg: *yyguts_t) void {
    if (yyg.yy_buffer_stack == null) {
        return;
    }

    const yy_current_buffer = yyg.yy_buffer_stack[yyg.yy_buffer_stack_top];
    if (yy_current_buffer == null) {
        return;
    }

    yy_delete_buffer(yy_current_buffer.?, yyg);
    yyg.yy_buffer_stack[yyg.yy_buffer_stack_top] = null;
    if (yyg.yy_buffer_stack_top > 0) {
        yyg.yy_buffer_stack_top -= 1;
    }

    if (yy_current_buffer != null) {
        yy_load_buffer_state(yyg);
        yyg.yy_did_buffer_switch_on_eof = true;
    }
}

/// Allocates the stack if it does not exist.
/// Guarantees space for at least one push.
///
pub fn yyensure_buffer_stack(yyg: *yyguts_t) !void {
    var num_to_alloc: usize = undefined;

    if (yyg.yy_buffer_stack == null) {
        // First allocation is just for 2 elements, since we don't know if this
        // scanner will even need a stack. We use 2 instead of 1 to avoid an
        // immediate realloc on the next call.
        //
        num_to_alloc = 1; // After all that talk, this was set to 1 anyways...
        yyg.yy_buffer_stack = (try yyg.lexer_.allocator.alloc(?*yy_buffer_state, num_to_alloc)).ptr;
        @memset(yyg.yy_buffer_stack[0..num_to_alloc], null);

        yyg.yy_buffer_stack_max = num_to_alloc;
        yyg.yy_buffer_stack_top = 0;
        return;
    }

    if (yyg.yy_buffer_stack_top >= (yyg.yy_buffer_stack_max - 1)) {
        // Increase the buffer to prepare for a possible push.
        const grow_size = 8; // arbitrary grow size

        num_to_alloc = yyg.yy_buffer_stack_max + grow_size;
        yyg.yy_buffer_stack = (try yyg.lexer_.allocator.alloc(?*yy_buffer_state, num_to_alloc)).ptr;

        // zero only the new slots.
        @memset(yyg.yy_buffer_stack[yyg.yy_buffer_stack_max..num_to_alloc], null);
        // memset(yyg.yy_buffer_stack + yyg.yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
        yyg.yy_buffer_stack_max = num_to_alloc;
    }
}

/// Setup the input buffer state to scan directly from a user-specified character buffer.
/// @param base the character buffer
/// @param size the size in bytes of the character buffer
/// @return the newly allocated buffer state object.
///
pub fn yy_scan_buffer(base: []u8, yyg: *yyguts_t) !*yy_buffer_state {
    var b: *yy_buffer_state = undefined;

    if (base.len < 2 or
        base[base.len - 2] != YY_END_OF_BUFFER_CHAR or
        base[base.len - 1] != YY_END_OF_BUFFER_CHAR)
    {
        // They forgot to leave room for the EOB's.
        return error.BufferBaseNotEnoughRoom;
    }

    b = try yyg.lexer_.allocator.create(yy_buffer_state);

    b.yy_buf_size = base.len - 2; // - 2 to take care of EOB's
    b.yy_buf_pos = base.ptr;
    b.yy_ch_buf = base.ptr;
    b.yy_is_our_buffer = false;
    b.yy_input_file = std.io.getStdIn();
    b.yy_n_chars = b.yy_buf_size;
    b.yy_is_interactive = false;
    b.yy_at_bol = true;
    b.yy_fill_buffer = false;
    b.yy_buffer_status = yy_buffer_state.YY_BUFFER_NEW;

    try yy_switch_to_buffer(b, yyg);

    return b;
}

/// Setup the input buffer state to scan a string. The next call to yylex() will
/// scan from a @e copy of @a str.
/// @param yystr a NUL-terminated string to scan
///
/// @return the newly allocated buffer state object.
/// @note If you want to scan bytes that may contain NUL values, then use
///       yy_scan_bytes() instead.
///
/// in zig just alias to yy_scan_bytes
pub const yy_scan_string = yy_scan_bytes;

/// Setup the input buffer state to scan the given bytes. The next call to yylex() will
/// scan from a @e copy of @a bytes.
/// @param yybytes the byte buffer to scan
/// @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
/// @return the newly allocated buffer state object.
///
pub fn yy_scan_bytes(yybytes: []const u8, yyg: *yyguts_t) !*yy_buffer_state {
    var b: *yy_buffer_state = undefined;
    const n: usize = yybytes.len + 2;

    // Get memory for full buffer, including space for trailing EOB's.
    var buf = try yyg.lexer_.allocator.alloc(u8, n);
    @memcpy(buf[0..yybytes.len], yybytes);
    buf[yybytes.len] = YY_END_OF_BUFFER_CHAR;
    buf[yybytes.len + 1] = YY_END_OF_BUFFER_CHAR;

    b = try yy_scan_buffer(buf, yyg);

    // It's okay to grow etc. this buffer, and we should throw it
    // away when we're done.
    //
    b.yy_is_our_buffer = true;
    return b;
}

pub fn yy_push_state(new_state: usize, yyg: *yyguts_t) !void {
    if (yyg.yy_start_stack_ptr >= yyg.yy_start_stack_depth) {
        var new_size: usize = 0;

        yyg.yy_start_stack_depth += YY_START_STACK_INCR;
        new_size = yyg.yy_start_stack_depth * @sizeOf(usize);

        if (yyg.yy_start_stack == 0) {
            yyg.yy_start_stack = try yyg.lexer.allocator.alloc(usize, new_size);
        } else {
            yyg.yy_start_stack = try yyg.lexer.allocator.realloc(usize, yyg.yy_start_stack, new_size);
        }

        yyg.yy_start_stack[yyg.yy_start_stack_ptr] = YY_START(yyg);
        yyg.yy_start_stack_ptr += 1;

        BEGIN(new_state, yyg);
    }
}

pub fn yy_pop_state(yyg: *yyguts_t) void {
    if (yyg.yy_start_stack_ptr <= 0)
        yy_fatal_error("start-condition stack underflow");
    yyg.yy_start_stack_ptr -= 1;
    BEGIN(yyg.yy_start_stack[yyg.yy_start_stack_ptr], yyg);
}

pub inline fn yy_top_state(yyg: *yyguts_t) usize {
    return yyg.yy_start_stack[yyg.yy_start_stack_ptr - 1];
}

pub fn yy_fatal_error(msg: []const u8) noreturn {
    std.debug.print("{s}\n", .{msg});
    std.os.exit(YY_EXIT_FAILURE);
}

// /* Redefine yyless() so it works in section 3 code. */
// TODO: WTF is this?

fn _yyless_2(n: usize, yyg: *yyguts_t) void {
    // Undo effects of setting up yytext.
    YY_LESS_LINENO(n, yyg);
    yyg.yytext_r[yyg.yyleng_r] = yyg.yy_hold_char;
    yyg.yy_c_buf_p = yyg.yytext_r + n;
    yyg.yy_hold_char = yyg.yy_c_buf_p.*;
    yyg.yy_c_buf_p.* = 0;
    yyg.yyleng = n;
}

// Accessor  methods (get/set functions) to struct members.

/// Get the user-defined data for this scanner.
pub inline fn yyget_extra(yyg: *yyguts_t) YY_EXTRA_TYPE {
    return yyg.yyextra;
}

/// Get the current line number.
pub inline fn yyget_lineno(yyg: *yyguts_t) usize {
    const yy_current_buffer = yyg.yy_buffer_stack[yyg.yy_buffer_stack_top];
    if (yy_current_buffer == 0)
        return 0;

    return yyg.yylineno;
}

/// Get the current column number.
pub fn yyget_column(yyg: *yyguts_t) usize {
    const yy_current_buffer = yyg.yy_buffer_stack[yyg.yy_buffer_stack_top];
    if (yy_current_buffer == 0)
        return 0;

    return yyg.yycolumn;
}

/// Get the input stream.
pub inline fn yyget_in(yyg: *yyguts_t) std.fs.File {
    return yyg.yyin;
}

/// Get the output stream.
pub inline fn yyget_out(yyg: *yyguts_t) std.fs.File {
    return yyg.yyout;
}

/// Get the length of the current token.
pub inline fn yyget_leng(yyg: *yyguts_t) usize {
    return yyg.yyleng_r;
}

/// Get the current token.
pub inline fn yyget_text(yyg: *yyguts_t) []const u8 {
    return yyg.yytext_r[0..yyg.yyleng_r];
}

/// Set the user-defined data. This data is never touched by the scanner.
/// @param user_defined The data to be associated with this scanner.
///
pub inline fn yyset_extra(user_defined: YY_EXTRA_TYPE, yyg: *yyguts_t) YY_EXTRA_TYPE {
    yyg.yyextra = user_defined;
}

/// Set the current line number.
/// @param _line_number line number
///
pub inline fn yyset_lineno(line_number: usize, yyg: *yyguts_t) void {
    const yy_current_buffer = yyg.yy_buffer_stack[yyg.yy_buffer_stack_top];
    if (yy_current_buffer == 0)
        yy_fatal_error("yyset_lineno called with no buffer");

    yyg.yylineno = line_number;
}

/// Set the current column.
/// @param _column_no column number
///
pub inline fn yyset_column(column_no: usize, yyg: *yyguts_t) void {

    // column is only valid if an input buffer exists.
    const yy_current_buffer = yyg.yy_buffer_stack[yyg.yy_buffer_stack_top];
    if (yy_current_buffer == 0)
        yy_fatal_error("yyset_column called with no buffer");

    yyg.yycolumn = column_no;
}

/// Set the input stream. This does not discard the current
/// input buffer.
/// @param _in_str A readable stream.
/// @see yy_switch_to_buffer
///
pub inline fn yyset_in(in_str: std.fs.File, yyg: *yyguts_t) void {
    yyg.yyin = in_str;
}

pub inline fn yyset_out(out_str: std.fs.File, yyg: *yyguts_t) void {
    yyg.yyout = out_str;
}

pub inline fn yyget_debug(yyg: *yyguts_t) bool {
    return yyg.yy_flex_debug;
}

pub inline fn yyset_debug(bdebug: bool, yyg: *yyguts_t) void {
    yyg.yy_flex_debug = bdebug;
}

// Accessor methods for yylval and yylloc

pub inline fn yyget_lval(yyg: *yyguts_t) *YYSTYPE {
    return yyg.yylval;
}

pub inline fn yyset_lval(yylval_param: *YYSTYPE, yyg: *yyguts_t) void {
    yyg.yylval = yylval_param;
}

pub inline fn yyget_lloc(yyg: *yyguts_t) *YYLTYPE {
    return yyg.yylloc;
}

pub inline fn yyset_lloc(yylloc_param: *YYLTYPE, yyg: *yyguts_t) void {
    yyg.yylloc = yylloc_param;
}

// User-visible API
// actually they are just as defined by traditional flex as user-visible
// zig output will have most functions use visible
// the difference here is below functions start to use this: *Self as the
// first param, where yyg can be easily got by this.yyg, and this.allocator

/// yylex_init is special because it creates the scanner itself, so it is
/// the ONLY reentrant function that doesn't take the scanner as the last
/// argument. That's why we explicitly handle the declaration, instead of
/// using our macros.
///
pub fn yylex_init(lexer: *Self) !void {
    lexer.yyg = try createZero(lexer.allocator, yyguts_t);
    lexer.yyg.lexer_ = lexer;
    yy_init_globals(lexer.yyg);
}

// and provide a zig style alias
pub const init = yylex_init;

/// yylex_init_extra has the same functionality as yylex_init, but follows the
/// convention of taking the scanner as the last argument. Note however, that
/// this is a *pointer* to a scanner, as it will be allocated by this call (and
/// is the reason, too, why this function also must handle its own declaration).
/// The user defined value in the first argument will be available to yyalloc in
/// the yyextra field.
///
pub fn yylex_init_extra(allocator: std.mem.Allocator, yy_user_defined: YY_EXTRA_TYPE) !Self {
    var self = try yylex_init(allocator);
    _ = &self;
    yyset_extra(yy_user_defined, self.yyg);
    return self;
}

pub const initExtra = yylex_init_extra;

pub fn yy_init_globals(yyg: *yyguts_t) void {
    // Initialization is the same as for the non-reentrant scanner.
    // This function is called from yylex_destroy(), so don't allocate here.
    //

    yyg.yy_buffer_stack = 0;
    yyg.yy_buffer_stack_top = 0;
    yyg.yy_buffer_stack_max = 0;
    yyg.yy_c_buf_p = 0;
    yyg.yy_init = false;
    yyg.yy_start = 1;

    yyg.yy_start_stack_ptr = 0;
    yyg.yy_start_stack_depth = 0;
    yyg.yy_start_stack = 0;

    yyg.yy_state_buf = 0;
    yyg.yy_state_ptr = 0;
    yyg.yy_full_match = 0;
    yyg.yy_lp = 0;

    // Defined in main.c
    yyg.yyin_r = std.io.getStdIn();
    yyg.yyout_r = std.io.getStdOut();

    yyg.yy_state_buf = (yyg.lexer_.allocator.alloc(usize, YY_STATE_BUF_SIZE) catch {
        yy_fatal_error("OOM! alloc yy_state_buf");
    }).ptr;
}

pub fn yylex_destroy(this: *Self) void {
    var yyg = this.yyg;
    var yy_current_buffer = yyg.yy_buffer_stack[yyg.yy_buffer_stack_top];
    // Pop the buffer stack, destroying each element.
    while (yy_current_buffer != null) {
        yy_delete_buffer(yy_current_buffer.?, yyg);
        yyg.yy_buffer_stack[yyg.yy_buffer_stack_top] = null;
        yypop_buffer_state(yyg);
        yy_current_buffer = yyg.yy_buffer_stack[yyg.yy_buffer_stack_top];
    }

    // Destroy the stack itself.
    this.allocator.free(yyg.yy_buffer_stack[0..yyg.yy_buffer_stack_max]);

    // Destroy the start condition stack.
    if (yyg.yy_start_stack != null and yyg.yy_start_stack_depth > 0) {
        this.allocator.free(yyg.yy_start_stack[0..yyg.yy_start_stack_depth]);
    }

    this.allocator.free(yyg.yy_state_buf[0..YY_STATE_BUF_SIZE]);

    // Reset the globals. This is important in a non-reentrant scanner so the
    // next time yylex() is called, initialization will occur.
    yy_init_globals(yyg);

    // Destroy the main struct (reentrant only).
    this.allocator.destroy(yyg);
}

pub const deinit = yylex_destroy;

// #line 406 "flex.l"

// user code
