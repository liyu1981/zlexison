pub const uint_ptr = usize;
const ZA = struct {
    pub var zyy_yyg_intptr: uint_ptr = undefined;

    pub const YYError = error{
        YYScanStringFailed,
        YYScanBytesFailed,
        YYScanBufferFailed,
    };

    pub const YYControl = struct {
        const E = error{
            RETURN,
            REJECT,
            TERMINATE,
            YYLESS,
            CONTINUE,
        };
        pub const INT_RETURN = 0;
        pub const INT_REJECT = 1;
        pub const INT_TERMINATE = 2;
        pub const INT_YYLESS = 3;
        pub const INT_CONTINUE = std.math.maxInt(c_int);
    };

    pub fn CONTINUE() !void {
        return YYControl.E.CONTINUE;
    }

    pub const YYGuts = extern struct {
        // /* User-defined. Not touched by flex. */
        // YY_EXTRA_TYPE yyextra_r;

        yyin_r: *std.c.FILE,
        yyout_r: *std.c.FILE,
        yy_buffer_stack_top: isize, // /**< index of top of stack. */
        yy_buffer_stack_max: isize, // /**< capacity of stack. */
        yy_buffer_stack: *YYBufferState, // /**< Stack as an array. */
        yy_hold_char: u8,
        yy_n_chars: c_int,
        yyleng_r: c_int,
        yy_c_buf_p: [*c]i8,
        yy_init: c_int,
        yy_start: c_int,
        yy_did_buffer_switch_on_eof: c_int,
        yy_start_stack_ptr: c_int,
        yy_start_stack_depth: c_int,
        yy_start_stack: *c_int,
        yy_last_accepting_state: c_int,
        yy_last_accepting_cpos: [*c]i8,

        yylineno_r: c_int,
        yy_flex_debug_r: c_int,

        yytext_r: [*c]i8,
        yy_more_flag: c_int,
        yy_more_len: c_int,
    };

    pub const YYBufferState = extern struct {
        yy_input_file: *std.c.FILE,
        yy_ch_buf: [*c]u8, // input buffer
        yy_buf_pos: [*c]u8, // current position in input buffer
        yy_buf_size: c_int, // Size of input buffer in bytes, not including room for EOB characters.
        yy_n_chars: c_int, // Number of characters read into yy_ch_buf, not including EOB characters.
        yy_is_our_buffer: c_int, // Whether we "own" the buffer - i.e., we know we created it,
        // and can realloc() it to grow
        // it, and should free() it to delete it.
        yy_is_interactive: c_int, // Whether this is an "interactive" input source; if so, and
        // if we're using stdio for input, then we want to use getc()
        // instead of fread(), to make sure we stop fetching input after
        // each newline.
        yy_at_bol: c_int, // Whether we're considered to be at the beginning of a line.
        // If so, '^' rules will be active on the next match, otherwise not.
        yy_bs_lineno: c_int, // *< The line count.
        yy_bs_column: c_int, // *< The column count.
        yy_fill_buffer: c_int, // Whether to try to fill the input buffer when we reach the end of it.
        yy_buffer_status: c_int,

        const YY_BUFFER_NEW = 0;
        const YY_BUFFER_NORMAL = 1;
        const YY_BUFFER_EOF_PENDING = 2; // When an EOF's been seen but there's still some text to process
        // then we mark the buffer as YY_EOF_PENDING, to indicate that we
        // shouldn't try reading from the input source any more.  We might
        // still have a bunch of tokens to match, though, because of
        // possible backing-up.
        //
        // When we actually see the EOF, we change the status to "new"
        // (via yyrestart()), so that the user can continue scanning by
        // just pointing yyin at a new input file.
    };

    pub const StartCondition = struct {
        pub fn BEGIN(this: *const StartCondition, start_condition: usize) void {
            _ = this;
            zyy_begin(zyy_yyg_intptr, start_condition);
        }

        pub fn yy_push_state(this: *const StartCondition, new_state: usize) void {
            _ = this;
            zyy_yy_push_state(zyy_yyg_intptr, new_state);
        }

        pub fn yy_pop_state(this: *const StartCondition) void {
            _ = this;
            zyy_yy_pop_state(zyy_yyg_intptr);
        }

        pub fn yy_top_state(this: *const StartCondition) usize {
            _ = this;
            return zyy_yy_top_state(zyy_yyg_intptr);
        }
    };

    // ch14, values available to the user
    pub const YY = struct {
        yyg: uint_ptr = undefined,
        text: [*c]u8 = undefined,
        leng: usize = undefined,
        in: uint_ptr = undefined,
        out: uint_ptr = undefined,
        current_buffer: *YYBufferState = undefined,
        start: usize = undefined,

        pub fn restart(this: *const YY, f: *std.c.FILE) void {
            _ = this;
            zyy_yyrestart(zyy_yyg_intptr, f);
        }
    };

    pub fn yyget_lineno() usize {
        return zyy_yyget_lineno(zyy_yyg_intptr);
    }

    pub fn yyget_column() usize {
        return zyy_yyget_column(zyy_yyg_intptr);
    }

    // ch8, actions
    pub const Action = struct {
        pub fn ECHO(this: *const Action) void {
            _ = this;
            zyy_ECHO(zyy_yyg_intptr);
        }

        // use REJECT as
        //     `return ZA.YYControl.E.REJECT;`

        pub fn yymore(this: *const Action) void {
            _ = this;
            zyy_yymore();
        }

        // use yyless as
        //     `ZA.Action.yyless(n); return ZA.YYControl.E.YYLESS;`
        pub fn yyless(this: *const Action, n: usize) void {
            _ = this;
            zyy_set_parser_param_reg(0, @as(c_int, @intCast(n)));
        }

        pub fn unput(this: *const Action, c: u8) void {
            _ = this;
            zyy_unput(zyy_yyg_intptr, c);
        }

        pub fn input(this: *const Action) ?u8 {
            _ = this;
            const c = zyy_input(zyy_yyg_intptr);
            if (c < 0) {
                return null;
            }
            return @as(u8, @intCast(c));
        }

        pub fn YY_FLUSH_BUFFER(this: *const Action) void {
            _ = this;
            zyy_YY_FLUSH_BUFFER(zyy_yyg_intptr);
        }

        // use yyterminate as:
        //     `return ZA.YYControl.E.TERMINATE;`
    };

    pub const Buffer = struct {
        pub fn yy_create_buffer(this: *const Buffer, f: std.c.FILE, size: usize) *YYBufferState {
            _ = this;
            const yybuf_intptr = zyy_yy_create_buffer(zyy_yyg_intptr, f, size);
            return @as(*YYBufferState, @ptrFromInt(yybuf_intptr));
        }

        pub fn yy_switch_to_buffer(this: *const Buffer, new_buffer: *YYBufferState) void {
            _ = this;
            zyy_yy_switch_to_buffer(zyy_yyg_intptr, @as(uint_ptr, @intFromPtr(new_buffer)));
        }

        pub fn yy_delete_buffer(this: *const Buffer, buffer: *YYBufferState) void {
            _ = this;
            zyy_yy_delete_buffer(zyy_yyg_intptr, @as(uint_ptr, @intFromPtr(buffer)));
        }

        pub fn yypush_buffer_state(this: *const Buffer, buffer: *YYBufferState) void {
            _ = this;
            zyy_yypush_buffer_state(zyy_yyg_intptr, @as(uint_ptr, @intFromPtr(buffer)));
        }

        pub fn yypop_buffer_state(this: *const Buffer) void {
            _ = this;
            zyy_yypop_buffer_state(zyy_yyg_intptr);
        }

        pub fn yy_flush_buffer(this: *const Buffer, buffer: *YYBufferState) void {
            _ = this;
            zyy_yy_flush_buffer(zyy_yyg_intptr, @as(uint_ptr, @intFromPtr(buffer)));
        }

        /// yy_new_buffer is an alias for yy_create_buffer(), provided for compatibility with the C++ use of new and delete
        /// for creating and destroying dynamic objects. We will only deal with c so skip it here.
        pub fn yy_new_buffer(this: *const Buffer, file: std.fs.File) YYBufferState {
            _ = this;
            _ = file;
            @compileError("yy_new_buffer in flex is for c++! just use yy_create_buffer.");
        }

        pub fn yy_scan_string(this: *const Buffer, str: []const u8) YYError!*YYBufferState {
            _ = this;
            const yybuf_intptr = zyy_yy_scan_string(zyy_yyg_intptr, str.ptr);
            if (yybuf_intptr == 0) {
                return YYError.YYScanStringFailed;
            } else {
                return @as(*YYBufferState, @ptrFromInt(yybuf_intptr));
            }
        }

        pub fn yy_scan_bytes(this: *const Buffer, str: []const u8) YYError!*YYBufferState {
            _ = this;
            const yybuf_intptr = zyy_yy_scan_bytes(zyy_yyg_intptr, str.ptr, str.len);
            if (yybuf_intptr == 0) {
                return YYError.YYScanBytesFailed;
            } else {
                return @as(*YYBufferState, @ptrFromInt(yybuf_intptr));
            }
        }

        pub fn yy_scan_buffer(this: *const Buffer, base: []u8) YYError!*YYBufferState {
            _ = this;
            const yybuf_intptr = zyy_yy_scan_buffer(zyy_yyg_intptr, base.ptr, base.len);
            if (yybuf_intptr == 0) {
                return YYError.YYScanBufferFailed;
            } else {
                return @as(*YYBufferState, @ptrFromInt(yybuf_intptr));
            }
        }
    };

    pub var YY_USER_ACTION: ?UserActionFn = null;
    pub var YY_USER_INIT: ?UserInitFn = null;

    pub const Misc = struct {
        // yy_set_interactive
        // skip this as our parser will never be interactive

        pub fn yy_set_bol(this: *const Misc, at_bol: isize) void {
            _ = this;
            zyy_yy_set_bol(zyy_yyg_intptr, at_bol);
        }

        pub fn YY_AT_BOL(this: *const Misc) bool {
            _ = this;
            return zyy_YY_AT_BOL(zyy_yyg_intptr) != 0;
        }

        // YYBREAK
        // skip this too :)
    };

    // alias

    pub const zyy_yyget_lineno = <= ctx.prefix : {s} =>_yyget_lineno;
    pub const zyy_yyget_column = <= ctx.prefix : {s} =>_yyget_column;
    pub const zyy_yyrestart = <= ctx.prefix : {s} =>_yyrestart;

    pub const zyy_yy_create_buffer = <= ctx.prefix : {s} =>_yy_create_buffer;
    pub const zyy_yy_switch_to_buffer = <= ctx.prefix : {s} =>_yy_switch_to_buffer;
    pub const zyy_yy_delete_buffer = <= ctx.prefix : {s} =>_yy_delete_buffer;
    pub const zyy_yypush_buffer_state = <= ctx.prefix : {s} =>_yypush_buffer_state;
    pub const zyy_yypop_buffer_state = <= ctx.prefix : {s} =>_yypop_buffer_state;
    pub const zyy_yy_flush_buffer = <= ctx.prefix : {s} =>_yy_flush_buffer;
    pub const zyy_yy_scan_string = <= ctx.prefix : {s} =>_yy_scan_string;
    pub const zyy_yy_scan_bytes = <= ctx.prefix : {s} =>_yy_scan_bytes;
    pub const zyy_yy_scan_buffer = <= ctx.prefix : {s} =>_yy_scan_buffer;

    pub const zyy_begin = <= ctx.prefix : {s} =>_begin;
    pub const zyy_yy_push_state = <= ctx.prefix : {s} =>_yy_push_state;
    pub const zyy_yy_pop_state = <= ctx.prefix : {s} =>_yy_pop_state;
    pub const zyy_yy_top_state = <= ctx.prefix : {s} =>_yy_top_state;

    pub const zyy_ECHO = <= ctx.prefix : {s} =>_ECHO;
    pub const zyy_yymore = <= ctx.prefix : {s} =>_yymore;
    pub const zyy_unput = <= ctx.prefix : {s} =>_unput;
    pub const zyy_input = <= ctx.prefix : {s} =>_input;
    pub const zyy_YY_FLUSH_BUFFER = <= ctx.prefix : {s} =>_YY_FLUSH_BUFFER;

    pub const zyy_yy_set_bol = <= ctx.prefix : {s} =>_yy_set_bol;
    pub const zyy_YY_AT_BOL = <= ctx.prefix : {s} =>_YY_AT_BOL;

    pub const zyylex_init = <= ctx.prefix : {s} =>lex_init;
    pub const zyylex = <= ctx.prefix : {s} =>lex;
    pub const zyylex_destroy = <= ctx.prefix : {s} =>lex_destroy;

    pub const zyy_setup_parser = <= ctx.prefix : {s} =>_setup_parser;
    pub const zyy_set_parser_param_reg = <= ctx.prefix : {s} =>_set_parser_param_reg;

    // externs

    pub extern fn <= ctx.prefix : {s} =>_yyget_lineno(yyg_intptr: uint_ptr) usize;
    pub extern fn <= ctx.prefix : {s} =>_yyget_column(yyg_intptr: uint_ptr) usize;
    pub extern fn <= ctx.prefix : {s} =>_yyrestart(yyg_intptr: uint_ptr, f: *std.c.FILE) void;

    pub extern fn <= ctx.prefix : {s} =>_yy_create_buffer(yyg_intptr: uint_ptr, f: std.c.FILE, size: usize) uint_ptr;
    pub extern fn <= ctx.prefix : {s} =>_yy_switch_to_buffer(yyg_intptr: uint_ptr, new_buffer: uint_ptr) void;
    pub extern fn <= ctx.prefix : {s} =>_yy_delete_buffer(yyg_intptr: uint_ptr, buffer: uint_ptr) void;
    pub extern fn <= ctx.prefix : {s} =>_yypush_buffer_state(yyg_intptr: uint_ptr, buffer: uint_ptr) void;
    pub extern fn <= ctx.prefix : {s} =>_yypop_buffer_state(yyg_intptr: uint_ptr) void;
    pub extern fn <= ctx.prefix : {s} =>_yy_flush_buffer(yyg_intptr: uint_ptr, buffer: uint_ptr) void;
    pub extern fn <= ctx.prefix : {s} =>_yy_scan_string(yyg_intptr: uint_ptr, str: [*c]const u8) uint_ptr;
    pub extern fn <= ctx.prefix : {s} =>_yy_scan_bytes(yyg_intptr: uint_ptr, str: [*c]const u8, len: usize) uint_ptr;
    pub extern fn <= ctx.prefix : {s} =>_yy_scan_buffer(yyg_intptr: uint_ptr, base: [*c]u8, size: usize) uint_ptr;

    extern fn <= ctx.prefix : {s} =>_begin(yyg_intptr: uint_ptr, start_condition: usize) void;
    pub extern fn <= ctx.prefix : {s} =>_yy_push_state(yyg_intptr: uint_ptr, new_state: usize) void;
    pub extern fn <= ctx.prefix : {s} =>_yy_pop_state(yyg_intptr: uint_ptr) void;
    pub extern fn <= ctx.prefix : {s} =>_yy_top_state(yyg_intptr: uint_ptr) usize;

    extern fn <= ctx.prefix : {s} =>_ECHO(yyg_intptr: uint_ptr) void;
    // pub extern fn zyy_REJECT(yyg_intptr: uint_ptr) void;
    pub extern fn <= ctx.prefix : {s} =>_yymore(yyg_intptr: uint_ptr) void;
    // pub extern fn zyy_yyless(yyg_intptr: uint_ptr, n: c_int) void;
    pub extern fn <= ctx.prefix : {s} =>_unput(yyg_intptr: uint_ptr, c: u8) void;
    pub extern fn <= ctx.prefix : {s} =>_input(yyg_intptr: uint_ptr) c_int;
    pub extern fn <= ctx.prefix : {s} =>_YY_FLUSH_BUFFER(yyg_intptr: uint_ptr) void;
    // yyterminate

    pub extern fn <= ctx.prefix : {s} =>_yy_set_bol(yyg_intptr: uint_ptr, at_bol: c_int) void;
    pub extern fn <= ctx.prefix : {s} =>_YY_AT_BOL(yyg_intptr: uint_ptr) c_int;


    pub extern fn <= ctx.prefix : {s} =>lex_init(yyg: [*c]?*anyopaque) c_int;
    pub extern fn <= ctx.prefix : {s} =>lex(yyg: ?*anyopaque) c_int;
    pub extern fn <= ctx.prefix : {s} =>lex_destroy(yyg: ?*anyopaque) c_int;

    pub extern fn <= ctx.prefix : {s} =>_setup_parser(parser_intptr: uint_ptr) void;
    pub extern fn <= ctx.prefix : {s} =>_set_parser_param_reg(index: usize, value: c_int) void;
};
const UserActionFn = *const fn (parser: *Parser) void;
const UserInitFn = *const fn (parser: *Parser) void;
pub export fn <= ctx.prefix : {s} =>_call_user_action(parser_intptr: uint_ptr) void {
    if (ZA.YY_USER_ACTION) |user_action_fn| {
        user_action_fn(@as(*Parser, @ptrFromInt(parser_intptr)));
    }
}
pub export fn <= ctx.prefix : {s} =>_call_user_init(parser_intptr: uint_ptr) void {
    if (ZA.YY_USER_INIT) |user_init_fn| {
        user_init_fn(@as(*Parser, @ptrFromInt(parser_intptr)));
    }
}
